/**
 * ALL FUNCTION IMPLEMENTATIONS AND HELPER FUNCTIONS FOR ENCODER WILL BE IN THIS FILE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include "common.h"
#include "encoder.h"
/**
 *
 * This function takes a char c as input and returns a (6 character) array
 * that represents the 6 digit code for that character. This code is simply
 * the index of the char in the MAPPING array (represented in binary). 
 * You should use the REVERSE\_MAPPING array in this function to get 
 * the binary code for the character. REVERSE\_MAPPING array MUST be 
 * initialized with createReverseMapping(), prior to calling this function.
 *
 * @param c The input character to encode
 * @returns a six character array which encodes the index into ASCII binary
 */
char* encodeChar(char c){
    char * charEncoding;                /* Array containing encoded char */
    int encodedChar;                    /* Encoded char as an int */
    int encodingIndex;                  /* index of for loop */
    int arrayIndex = 0;                 /* Index to iterate reversed */
    int bitMask = 1;                    /* Used to extract a certain bit */
    int maskedBits = 0;                 /* Result of masking bits */

    /* Initialize REVERSE MAPPING */
    createReverseMapping();

    /* Initializes an array whose indices represent the 6 digit code */
    charEncoding = calloc(6, sizeof(char));

    /* Grab the code of the char */
    encodedChar = REVERSE_MAPPING[(int) c];

    /* Populate the array in reverse order */
    for (encodingIndex = 5; encodingIndex >= 0; encodingIndex--) {

        /* Grab the bit in the (index)th position */
        maskedBits = (bitMask << encodingIndex) & encodedChar;

        /* Assign the corresponding value in the array as a char */
        if (!maskedBits) {

            /* Bit at position is 0 */
            charEncoding[arrayIndex] = '0';
        }
        else {

            /* Bit at position is 1 */
            charEncoding[arrayIndex] = '1';
        }

        /* Separately increment the arrayIndex */
        arrayIndex++;

    }

    /* Return pointer to array */
    return charEncoding;
}



/**
 * Takes a char c and int bit (should be either 0 or 1) and int index as input. 
 * Sets the bit at input index of c to be the input bit and returns the result.
 * The 0 index refers to the LSB, so for example, index 2 should 
 * set the 3rd least significant bit.
 * 
 * @param c the char to implant a bit into
 * @param bit the bit value to implant (0 or 1)
 * @param index the index to implant the bit into (0 is LSB)
 * @returns the char with bit b implanted into the input index
 */
char implantBit(char c, int bit, int index){
    int mask;                           /* Used to erase the bit at index */
    char editedChar;                    /* Char with implanted bit */

    /* Shift the bit to implant by desired index */
    bit = bit << index;

    /* Create mask to erase bit at desired index */
    mask = ~(1 << index);

    /* Erase the bit at desired index and replace with desired bit */
    editedChar = c & mask;
    editedChar = editedChar | bit;
    return editedChar;
}



/**
 * Takes a FILE handle in as input (corresponding to a regular ASCII
 * text file) and reads the file, char by char. Encodes each char into
 * a 6 character "binary" char array (by calling encodeChar).  The
 * resulting character arrays should be written to the output file
 * handle out
 *
 * @param in The input text file to read
 * @param out The output file, in ASCII encoded "binary"
 */
void textToBinary(FILE *in, FILE *out){
    int inputChar;                         /* Char from input */
    char * encodedChar;                     /* char we encoded from input */

    /* Check that input and output streams are valid */
    if ((!in) | (!out)) {
        return;
    }

    /* Continue reading until end of file */
    while (1) {

        
        /* Read in one char at a time */
        inputChar = fgetc(in);

        /* Check that it wasn't end of file */
        if (inputChar == EOF) {
            break;
        }

        /* Encode the char and write to output */
        encodedChar = encodeChar(inputChar);
        fwrite(encodedChar, sizeof(char), 6, out);

        /* Free the memory in heap used by encodedChar */
        free((void *) encodedChar);

    }

    return;
}



/**
 * Takes a FILE handle in as input (corresponding to a
 * "binary" encoded file) and reads the file 1 char at a time. Each
 * char read will be an ASCII '0' or ASCII '1', and either 0 or 1 
 * will be implanted into randomized chars generated by rand()%256.
 *
 * If ASCII '0', then implant 0 into the bit at the input index 
 * of a randomized char . If ASCII '1', then implant 1 into the bit at 
 * the input index of the randomized char (by calling implantBit). 
 * Write the result into the output file handle out 
 * (Note: The least significant bit is in index 0)
 *
 * @param in The input file handle to read (ASCII encoded binary)
 * @param out The output file to write to
 * @param index the index of the bit where binary values should be implanted (0 is LSB)
 */
void binaryToCode(FILE *in, FILE *out, int index){
    int asciiOffset = 48;               /* ASCII 0 is 48, ASCII 1 is 49 */
    int encodedChar;
    int encodedCharValue;
    char randomChar;

    srand(1); //DO NOT REMOVE OR EDIT THIS LINE OF CODE

    /* Check that input and output streams are valid */
    if ((!in) || (!out)) {
        return;
    }

    /* Continue reading until end of file */
    while (1) {

        
        /* Read in one char at a time */
        encodedChar = fgetc(in);

        /* Check that it wasn't end of file */
        if (encodedChar == EOF) {
            break;
        }

        /* Convert ASCII ('0' or '1') to decimal (0 or 1) */
        encodedCharValue = encodedChar - asciiOffset;

        /* Implant the bit in a random char and write it out */
        randomChar = implantBit((rand() % 256), encodedCharValue, index);
        fwrite(&randomChar, sizeof(char), 1, out);

    }

    return;
}

/**
 * Reads in a file from the specified input path and outputs a a binary encoding to
 * specified bin path and a fully encoded version to specified output path. 
 * This should simply open the necessary files and call the above helper 
 * functions in the correct sequence, and close the necessary files.
 *
 * @param input the path to the input file
 * @param bin the path to the encoded ASCII binary output file
 * @param output the path to the encoded output file 
 * @param index The index of the bit where binary values should be implanted (0 is LSB)
*/
void encodeFile(char* input, char* bin, char* output, int index){
    FILE * in;
    FILE * out;
    FILE * binaryOut;

    /* Open filestreams for input, binary output, and encoded */
    in = fopen(input, "rwb");
    binaryOut = fopen(bin, "wb");
    out = fopen(output, "wb");

    /* Check that all filestreams are valid */
    if ((!in) || (!out) || (!binaryOut)) {
      return;
    }

    /* Convert textfile to binary */
    textToBinary(in, binaryOut);
    fclose(in);
    fclose(binaryOut);

    /* Reopen binary input to encode */
    binaryOut = fopen(bin, "rb");
    binaryToCode(binaryOut, out, index);
    fclose(binaryOut);
    fclose(out);
}
